{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fff015b8_3c4eb5c3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2023-10-26T07:56:16Z",
      "side": 1,
      "message": "Can you expand a bit on this?\n- How can the events be processed multiple times? The `fireBeforeStartupEvents` is called only once by the `start` `LifecycleListener`, no?\n\n- Even if the event is processed multiple times, would that be an issue? I thought that fetch operations were idempotent.  Can you bring some example?",
      "range": {
        "startLine": 12,
        "startChar": 55,
        "endLine": 13,
        "endChar": 58
      },
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e37684f6_57a4b858",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1149185
      },
      "writtenOn": "2023-10-26T08:16:30Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "fff015b8_3c4eb5c3",
      "range": {
        "startLine": 12,
        "startChar": 55,
        "endLine": 13,
        "endChar": 58
      },
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "444c803e_5ae1e339",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2023-10-26T09:48:27Z",
      "side": 1,
      "message": "\u003eHow can the events be processed multiple times? The fireBeforeStartupEvents is \u003ecalled only once by the start LifecycleListener, no?\n\nConfiguration auto-reload is triggered event time we modify the replication config. The difference is that auto-reload call stop/start and doesn\u0027t unload the plugin. This means that `beforeStartupEventsQueue` is not recreated and because we do not clean up the queue it will contain old events so we will send the same messages again\n\n\u003eEven if the event is processed multiple times, would that be an issue? I thought \u003ethat fetch operations were idempotent. Can you bring some example?\n\nIn this change we still call fire method which is doing apply-object or fetch. For apply-object we have SHA1 in the event so we will send the old ref value. There is a change to force fetch:\nhttps://gerrit-review.googlesource.com/c/plugins/pull-replication/+/390981",
      "parentUuid": "fff015b8_3c4eb5c3",
      "range": {
        "startLine": 12,
        "startChar": 55,
        "endLine": 13,
        "endChar": 58
      },
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef34eba6_6faa508f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2023-10-26T21:57:26Z",
      "side": 1,
      "message": "Best to explain in the commit message that the replication operations *may not* be idempotent.",
      "parentUuid": "444c803e_5ae1e339",
      "range": {
        "startLine": 12,
        "startChar": 55,
        "endLine": 13,
        "endChar": 58
      },
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4be15527_762356a2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1161425
      },
      "writtenOn": "2023-10-31T12:26:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ef34eba6_6faa508f",
      "range": {
        "startLine": 12,
        "startChar": 55,
        "endLine": 13,
        "endChar": 58
      },
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e802db9_08000da6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1149185
      },
      "writtenOn": "2023-10-25T15:14:58Z",
      "side": 1,
      "message": "What is the plan for testing?",
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3883f03_6d06d7b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2023-10-26T09:48:27Z",
      "side": 1,
      "message": "It is tough to write a test for this specific condition and verifying it. We wrote some unit test but it\u0027s a white-box test and our current approach is to avoid those type of tests:\n\n```\n  public void shouldProcessBeforeStartupEventsOnce() throws Exception {\n    Event event \u003d new TestEvent(\"refs/changes/01/1/meta\");\n    objectUnderTest.stop();\n    objectUnderTest.onEvent(event);\n    verify(fetchRestApiClient, never()).callSendObjects(any(), anyString(), anyLong(), any(), any());\n\n    objectUnderTest.start();\n    verify(fetchRestApiClient).callSendObjects(any(), anyString(), anyLong(), any(), any());\n\n    objectUnderTest.stop();\n    objectUnderTest.start();\n    verify(fetchRestApiClient).callSendObjects(any(), anyString(), anyLong(), any(), any());\n  }\n```",
      "parentUuid": "1e802db9_08000da6",
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a999c3e_6f43906b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2023-11-13T13:28:03Z",
      "side": 1,
      "message": "I don\u0027t believe we need to leak the implementation details in the tests: we just need to check that after the start of the plugin, if there were events before starting, the queue is empty.\n\nThe fact that we call `sendObjects()` as part of the replication of `refs/changes/01/1/meta` is unneeded and leaking implementation details.",
      "parentUuid": "e3883f03_6d06d7b1",
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c4509ac_0773d85a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2023-11-14T08:54:10Z",
      "side": 1,
      "message": "Marking as resolved, as adding white-box testing won\u0027t really make the one-liner change more robust IMHO.",
      "parentUuid": "8a999c3e_6f43906b",
      "revId": "39ed50189797c89d51675900971294947414a3dc",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}