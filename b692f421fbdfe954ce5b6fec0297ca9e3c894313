{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "875c9a48_90707f6b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2023-05-16T12:26:20Z",
      "side": 1,
      "message": "Wouldn\u0027t that be the expected behaviour in a multi-primary setup, where a single instance is client and server of fetches for pull-replication at the same time?",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "119fa34b_f38773f8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2023-05-16T14:25:54Z",
      "side": 1,
      "message": "I believe that this option is dangerous for primary/replica setup. In that setup the fetch direction is always: replica fetches from primary.\n\nIn a multi-site setup, a primary may fetch from another primary. What would replicateOnStartup mean in a multi-site scenario where there are multiple remote sections in the replication.config (like every of N primaries knows the rest of N-1 primaries). Which other site it would fetch from (one of them, all of them)? The semantics here are unclear to me.\n\nThe point of this change is that we need protection for primary fetching all from replica, and that protection needs to be stronger than relying on Gerrit admin to set replicateOnStartup \u003d false on the primary side. I am open for other suggestions about how to approach this problem. Maybe we can have an REST API endpoint \"is-replica\" where one site can check if a remote is replica of primary?",
      "parentUuid": "875c9a48_90707f6b",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edd28106_625431a7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2023-05-17T07:09:39Z",
      "side": 1,
      "message": "\u003e In a multi-site setup, a primary may fetch from another primary. What would replicateOnStartup mean in a multi-site scenario where there are multiple remote sections in the replication.config (like every of N primaries knows the rest of N-1 primaries). Which other site it would fetch from (one of them, all of them)? The semantics here are unclear to me.\n\nGood question. I think just fetching from one other primary (if n \u003e 2) would be dangerous, since the other primaries might not all have the same state yet. Maybe this could be more intelligently solved by making use of the data in the global RefDB (which would be available in such a setup), instead of blindly fetching everything from every other primary, which when done sequentially should also work. The first fetch would be the largest and then the subsequent ones would just get the commits that were not available yet on the other instances.\n\n\u003e The point of this change is that we need protection for primary fetching all from replica, and that protection needs to be stronger than relying on Gerrit admin to set replicateOnStartup \u003d false on the primary side. I am open for other suggestions about how to approach this problem. Maybe we can have an REST API endpoint \"is-replica\" where one site can check if a remote is replica of primary?\n\nWouldn\u0027t it be enough, just not to configure `remote.\u003cname\u003e.url`, which we anyway shouldn\u0027t do if the remote is a replica?",
      "parentUuid": "119fa34b_f38773f8",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bb7421c_a93afa57",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1004034
      },
      "writtenOn": "2023-05-17T11:09:19Z",
      "side": 1,
      "message": "I think fetching from all other primaries only works fine if there are no forced updates (by some user using push -f). \n\nFor the following let\u0027s assume we have 3 primary sites P1, P2, P3 in a multi-site setup.\n\nIf a forced update was executed on P1, immediately after this update the other primaries P2, P3 are out-of-sync. When these other primaries get notified and then fetch (I assume with fetch -f option) from all other primaries the result depends on the fetch order:\n\n- If P3 first fetches from P2 and then from P1 the forced update is replicated correctly.\n- If P2 first fetches from P1 and then from P3 the forced update is lost on P2.",
      "parentUuid": "edd28106_625431a7",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fcdaac5_29e2cd2e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2023-05-18T20:27:29Z",
      "side": 1,
      "message": "\u003e I think fetching from all other primaries only works fine if there are no forced updates (by some user using push -f). \n\u003e \n\u003e For the following let\u0027s assume we have 3 primary sites P1, P2, P3 in a multi-site setup.\n\u003e \n\u003e If a forced update was executed on P1, immediately after this update the other primaries P2, P3 are out-of-sync.\n\nCorrect.\n\n\u003e When these other primaries get notified and then fetch (I assume with fetch -f option) from all other primaries the result depends on the fetch order:\n\u003e \n\u003e - If P3 first fetches from P2\n\nP3 does not fetch from P2 because the ref-update event happened on P1, therefore the ref-updated event has the P1\u0027s instance-id.\n\n\u003e and then from P1 the forced update is replicated correctly.\n\nP3 fetches from P1 only\n\n\u003e - If P2 first fetches from P1 and then from P3 the forced update is lost on P2.\n\nP2 fetches from P1 only",
      "parentUuid": "1bb7421c_a93afa57",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2662699_c9b9e4b9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1004034
      },
      "writtenOn": "2023-06-13T11:31:23Z",
      "side": 1,
      "message": "Ok, this means replication always fetches from the instance which did the ref update which solves this problem. But this implies that if P1 becomes unavailable after it sent the event and before replication to the other instances finished we are stuck since P2 and P3 can only catch up if P1 comes up again.",
      "parentUuid": "4fcdaac5_29e2cd2e",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1ef0050_2537548b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2023-07-07T13:23:39Z",
      "side": 1,
      "message": "The discussion here diverged from the primary-replica setup to a multi-primary setup. The purpose of this change is to make sure that in a primary-replica setup, the primary doesn\u0027t fetch from the replica when, maybe only by mistake, the `replicateOnStartup \u003d true` on primary.",
      "parentUuid": "a2662699_c9b9e4b9",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "b692f421fbdfe954ce5b6fec0297ca9e3c894313",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}